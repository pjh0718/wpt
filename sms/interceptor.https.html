<!DOCTYPE html>
<link rel="help" href="https://github.com/samuelgoto/sms-receiver">
<title>Tests the SMS Receiver API</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<!--
 sms_provider.js is a testing framework that enables engines to test the sms
 receiver API by intercepting the connection between the browser and the
 underlying operating system and mock its behavior.

 Usage:

 1) Include <script src="./sms_provider.js"></script> in your test.
 2) Set expectations
  let mock = new MockCall(getNextMessage);
  await mock.andReturnOnce((timeout) => {
    // mock behavior
  })
 3) Call navigator.sms.receive()
 4) Verify results

 The mocking API is browser agnostic and is designed such that other engines
 could implement it too.

 Here are the symbols that are exposed to tests that need to be implemented
 per engine:

 - function getNextMessage(): the main/only function that can be mocked.
 - MockCall: enables us to mock the function.
 - enum State {kSuccess, kTimeout}: allows you to mock success/failures.

  -->
<script src="./sms_provider.js"></script>
<script>
'use strict';

promise_test(async t => {
  let mock = new MockCall(getNextMessage);
  await mock.andReturnOnce((timeout) => {
      return Promise.resolve({
        sms: {
          content: "hello",
          status: Status.kSuccess,
        }
      });
  });

  let sms = await navigator.sms.receive();

  assert_equals(sms.content, "hello");
}, 'Basic usage');

promise_test(async t => {
  let mock = new MockCall(getNextMessage);
  await mock.andReturnOnce((timeout) => {
      return Promise.resolve({
        sms: {
          content: "hello1",
          status: Status.kSuccess,
        }
      });
  });
  await mock.andReturnOnce((timeout) => {
      return Promise.resolve({
        sms: {
          content: "hello2",
          status: Status.kSuccess,
        }
      });
  });

  let sms1 = navigator.sms.receive();
  let sms2 = navigator.sms.receive();

  let msg1 = await sms1;
  let msg2 = await sms2;

  assert_equals(msg1.content, "hello1");
  assert_equals(msg2.content, "hello2");
}, 'Handle multiple requests.');

promise_test(async t => {
  let mock = new MockCall(getNextMessage);
  await mock.andReturnOnce((timeout) => {
      return Promise.resolve({
        sms: {
          content: "",
          status: Status.kTimeout,
        }
      });
  });

  try {
    await navigator.sms.receive();
  } catch (error) {
    assert_equals(error.name, "TimeoutError");
    assert_equals(error.message, "SMSReceiver timed out.");
  }
}, 'Deal with timeouts');

promise_test(async t => {
  try {
    await navigator.sms.receive({timeout: 0});
  } catch (error) {
    assert_equals(error.name, "NotSupportedError");
    assert_equals(error.message, "Invalid timeout.");
  }
}, 'Should throw error with invalid timeout (0)');

promise_test(async t => {
  try {
    await navigator.sms.receive({timeout: null});
  } catch (error) {
    assert_equals(error.name, "NotSupportedError");
    assert_equals(error.message, "Invalid timeout.");
  }
}, 'Should throw error with invalid timeout (null)');

promise_test(async t => {
  try {
    await navigator.sms.receive({timeout: -1});
  } catch (error) {
    assert_equals(error.name, "NotSupportedError");
    assert_equals(error.message, "Invalid timeout.");
  }
}, 'Should throw error with invalid timeout (-1)');

promise_test(async t => {
  try {
    await navigator.sms.receive({timeout: NaN});
  } catch (error) {
    assert_equals(error.name, "NotSupportedError");
    assert_equals(error.message, "Invalid timeout.");
  }
}, 'Should throw error with invalid timeout (NaN)');

promise_test(async t => {
  let mock = new MockCall(getNextMessage);
  await mock.andReturnOnce((timeout) => {
      return Promise.resolve({
        sms: {
          content: "hello",
          status: Status.kSuccess,
        }
      });
  });

  let sms = await navigator.sms.receive({timeout: undefined});
  assert_equals(sms.content, "hello");
}, 'Should use default value for timeout (undefined)');
</script>

<!DOCTYPE html>
<html>
<title>respondWith cannot be called asynchronously</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
// This file has tests that call respondWith() asynchronously.

function wait_for_message() {
  return new Promise((resolve) => {
    const handler = (event) => {
      navigator.serviceWorker.removeEventListener('message', handler);
      resolve(event.data);
    };
    navigator.serviceWorker.addEventListener('message', handler);
  });
}

async function initialize_message_handler(worker) {
  const promise = wait_for_message();
  worker.postMessage('initializeMessageHandler');
  const response = await promise;
  assert_equals('messageHandlerInitialized', response);
}

// Does one test case. The service worker gets a fetch event for |url| and
// attempts to call respondWith() asynchronously. It reports back to the test
// whether an exception was thrown.
function fetch_event_async_respond_with_test(url, f, name) {
  const script = 'resources/fetch-event-async-respond-with-worker.js';
  const scope = 'resources/simple.html';

  promise_test(async (t) => {
    // Setup client.
    const registration =
        await service_worker_unregister_and_register(t, script, scope);
    const worker = registration.installing;
    await wait_for_state(t, worker, 'activated');
    const frame = await with_iframe(scope);
    t.add_cleanup(() => {
      frame.remove();
      return registration.unregister();
    });

    // Setup worker.
    await initialize_message_handler(worker);

    // Register message handler before starting the fetch
    // to ensure we don't miss the response.
    const result = wait_for_message(worker);
    frame.contentWindow.fetch(url);
    return f(await result);
  }, name);
}

fetch_event_async_respond_with_test('respondWith-in-task', (result) => {
  assert_true(result.didThrow, 'should throw');
  assert_equals(result.error, 'InvalidStateError');
}, 'respondWith in a task throws InvalidStateError');

fetch_event_async_respond_with_test('respondWith-in-microtask', (result) => {
  assert_false(result.didThrow, 'should not throw');
}, 'respondWith in a microtask does not throw');
</script>
</html>
